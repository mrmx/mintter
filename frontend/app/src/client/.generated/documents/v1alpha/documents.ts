// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
//@ts-nocheck
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
//@ts-nocheck
/* eslint-disable */
import { grpc } from "@improbable-eng/grpc-web";
import { BrowserHeaders } from "browser-headers";
import _m0 from "protobufjs/minimal";
import { Empty } from "../../google/protobuf/empty";
import { Timestamp } from "../../google/protobuf/timestamp";

/** Request to create a new draft. */
export interface CreateDraftRequest {
  /**
   * Optional. Existing Document ID can be specified to update
   * previously published document. A draft will be created
   * with the content of the most recent known version.
   */
  existingDocumentId: string;
}

/** Request to delete an existing draft. */
export interface DeleteDraftRequest {
  /** ID of the document whose draft needs to be deleted. Only one */
  documentId: string;
}

/** Request to get a single draft. */
export interface GetDraftRequest {
  /** ID of the document for which draft was previously created. */
  documentId: string;
}

/** Request to update an existing draft using granular operations. */
export interface UpdateDraftRequestV2 {
  /** ID of the document to be updated. */
  documentId: string;
  /** List of document changes that must be applied to the existing document. */
  changes: DocumentChange[];
}

/** Granular document change. */
export interface DocumentChange {
  op?:
    | { $case: "setTitle"; setTitle: string }
    | { $case: "setSubtitle"; setSubtitle: string }
    | { $case: "moveBlock"; moveBlock: DocumentChange_MoveBlock }
    | { $case: "replaceBlock"; replaceBlock: Block }
    | { $case: "deleteBlock"; deleteBlock: string };
}

/**
 * Operation to move an existing block to a different place in the document.
 * Move and Create operations are both expressed with this.
 * Conceptually new blocks are moved out of nowhere into the document.
 */
export interface DocumentChange_MoveBlock {
  /** ID of the block to move. */
  blockId: string;
  /** ID of the new parent for the block being moved. */
  parent: string;
  /** ID of the new left sibling for the block being moved. */
  leftSibling: string;
}

/** Request to list stored drafts. */
export interface ListDraftsRequest {
  /** Optional. Number of results per page. */
  pageSize: number;
  /** Optional. Token for the page to return. */
  pageToken: string;
}

/** Response for listing drafts. */
export interface ListDraftsResponse {
  /**
   * Drafts matching the list request.
   * Content is omitted.
   */
  documents: Document[];
  /** Token for the next page if there're any. */
  nextPageToken: string;
}

/** Request to publish a draft. */
export interface PublishDraftRequest {
  /** ID of the document which current draft needs to be published. */
  documentId: string;
}

/** Request for getting a single publication. */
export interface GetPublicationRequest {
  /** Required. ID of the published document. */
  documentId: string;
  /** Optional. Specific version of the published document. If empty, the latest one is returned. */
  version: string;
}

/** Request for deleting a publication. */
export interface DeletePublicationRequest {
  /**
   * Document ID of the publication to be removed.
   * All versions will also be removed.
   */
  documentId: string;
}

/** Request for listing publications. */
export interface ListPublicationsRequest {
  /** Optional. Number of results per page. Default is defined by the server. */
  pageSize: number;
  /** Optional. Value from next_page_token obtains from a previous response. */
  pageToken: string;
}

/** Response with list of publications. */
export interface ListPublicationsResponse {
  /**
   * List of publications matching the request.
   * Only most recent versions are returned.
   * Content is omitted, only metadata is present.
   */
  publications: Publication[];
  /** Token for the next page if there're more results. */
  nextPageToken: string;
}

export interface ListCitationsRequest {
  /** Required. Document ID for which citations need to be retrieved. */
  documentId: string;
  /**
   * Optional. Depth can be used to request transitive closure of citations.
   * For example depth=1 will return not only citations of the requested document_id
   * but also citations of those direct citations. The default is depth=0 and will only
   * return direct citations.
   */
  depth: number;
}

/** Response with citations. */
export interface ListCitationsResponse {
  /** List of links that point to the requested document, recursively, according to the requested depth. */
  links: Link[];
}

/** State of the document after publication. */
export interface Publication {
  /**
   * Version points to the state of the publication at some point in time.
   * It is represented as a string, although it can be a list of CIDs.
   * The order of hashes must be deterministic, which is tricky because
   * CIDs can have different base encoding when represented as a string.
   * So same hash, can have different string representations.
   * We should either define a canonical base encoding, or sort binary
   * representation of the hash portion of the CID.
   * Anyway, all these details should be opaque for consumers of this API.
   * On the other hand, if API consumers never compare versions as plain strings
   * it doesn't really matter if different version strings point to the same document.
   */
  version: string;
  /** Document metadata. */
  document: Document | undefined;
}

/** Document represents metadata and content of a draft or publication. */
export interface Document {
  /** Permanent ID of the document. */
  id: string;
  /** Title of the document. */
  title: string;
  /** Subtitle of the document. */
  subtitle: string;
  /** Output only. Author of the document. */
  author: string;
  /** This is WIP feature for block-aware API. It will supersede the `content` field. */
  children: BlockNode[];
  /** Output only. Time when document was created. */
  createTime: Date | undefined;
  /** Output only. Time when document was updated. */
  updateTime: Date | undefined;
  /** Output only. Time when this version was published. Not present in drafts. */
  publishTime: Date | undefined;
}

/** Content block with children. */
export interface BlockNode {
  /** Content block. */
  block: Block | undefined;
  /** Child blocks. */
  children: BlockNode[];
}

/** Content block. */
export interface Block {
  /** Block ID. Must be unique within the document. */
  id: string;
  /** Type of the block. Specific to the renderer. */
  type: string;
  /** Text of the content block. */
  text: string;
  /** Arbitrary attributes of the block. */
  attributes: Record<string, unknown>;
  /** Annotation "layers" of the block. */
  annotations: Annotation[];
}

export interface Block_AttributesEntry {
  key: string;
  value: string;
}

/**
 * Conceptual annotation "layer" that is applied to arbitrary spans of block text.
 * An "identity" of the layer should be derived deterministically based on its type
 * attributes. Spans inside the same annotation can't overlap.
 *
 * Spans are stored inside the Annotation in a "columnar" format,
 * i.e. StructureOfArrays instead of ArrayOfStructures. See: https://en.wikipedia.org/wiki/AoS_and_SoA.
 * This is useful to reduce the number of allocations and offers more compact serialization, because
 * protobuf is able to "pack" primitive repeated fields more efficiently.
 */
export interface Annotation {
  /** Type of the annotation. */
  type: string;
  /** Arbitrary key-value attributes of the annotation. */
  attributes: { [key: string]: string };
  /**
   * Start offsets of possibly disjoint spans of text for which this annotation is applied.
   * Must be sorted and have the same number of items as `ends` list.
   */
  starts: number[];
  /**
   * End offsets of possibly disjoint spans of text for which this annotation is applied.
   * Must be sorted and have the same number of items as `starts` list.
   */
  ends: number[];
}

export interface Annotation_AttributesEntry {
  key: string;
  value: string;
}

/** Description of a link inside a document. */
export interface Link {
  /** Required. Describes where link originates from. */
  source: LinkNode | undefined;
  /**
   * Required. Describes where link points to.
   * Here the block_id is optional, because the whole document can be linked.
   */
  target: LinkNode | undefined;
}

/** Describes "sides" of a Link. */
export interface LinkNode {
  /** ID of the document on one side of a Link. */
  documentId: string;
  /** Version of the document. */
  version: string;
  /** ID of the block inside the document. */
  blockId: string;
}

function createBaseCreateDraftRequest(): CreateDraftRequest {
  return { existingDocumentId: "" };
}

export const CreateDraftRequest = {
  encode(
    message: CreateDraftRequest,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.existingDocumentId !== "") {
      writer.uint32(10).string(message.existingDocumentId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateDraftRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateDraftRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.existingDocumentId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CreateDraftRequest {
    return {
      existingDocumentId: isSet(object.existingDocumentId)
        ? String(object.existingDocumentId)
        : "",
    };
  },

  toJSON(message: CreateDraftRequest): unknown {
    const obj: any = {};
    message.existingDocumentId !== undefined &&
      (obj.existingDocumentId = message.existingDocumentId);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<CreateDraftRequest>, I>>(
    object: I
  ): CreateDraftRequest {
    const message = createBaseCreateDraftRequest();
    message.existingDocumentId = object.existingDocumentId ?? "";
    return message;
  },
};

function createBaseDeleteDraftRequest(): DeleteDraftRequest {
  return { documentId: "" };
}

export const DeleteDraftRequest = {
  encode(
    message: DeleteDraftRequest,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.documentId !== "") {
      writer.uint32(10).string(message.documentId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteDraftRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteDraftRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.documentId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DeleteDraftRequest {
    return {
      documentId: isSet(object.documentId) ? String(object.documentId) : "",
    };
  },

  toJSON(message: DeleteDraftRequest): unknown {
    const obj: any = {};
    message.documentId !== undefined && (obj.documentId = message.documentId);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<DeleteDraftRequest>, I>>(
    object: I
  ): DeleteDraftRequest {
    const message = createBaseDeleteDraftRequest();
    message.documentId = object.documentId ?? "";
    return message;
  },
};

function createBaseGetDraftRequest(): GetDraftRequest {
  return { documentId: "" };
}

export const GetDraftRequest = {
  encode(
    message: GetDraftRequest,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.documentId !== "") {
      writer.uint32(10).string(message.documentId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetDraftRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDraftRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.documentId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetDraftRequest {
    return {
      documentId: isSet(object.documentId) ? String(object.documentId) : "",
    };
  },

  toJSON(message: GetDraftRequest): unknown {
    const obj: any = {};
    message.documentId !== undefined && (obj.documentId = message.documentId);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetDraftRequest>, I>>(
    object: I
  ): GetDraftRequest {
    const message = createBaseGetDraftRequest();
    message.documentId = object.documentId ?? "";
    return message;
  },
};

function createBaseUpdateDraftRequestV2(): UpdateDraftRequestV2 {
  return { documentId: "", changes: [] };
}

export const UpdateDraftRequestV2 = {
  encode(
    message: UpdateDraftRequestV2,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.documentId !== "") {
      writer.uint32(26).string(message.documentId);
    }
    for (const v of message.changes) {
      DocumentChange.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): UpdateDraftRequestV2 {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateDraftRequestV2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          message.documentId = reader.string();
          break;
        case 4:
          message.changes.push(DocumentChange.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): UpdateDraftRequestV2 {
    return {
      documentId: isSet(object.documentId) ? String(object.documentId) : "",
      changes: Array.isArray(object?.changes)
        ? object.changes.map((e: any) => DocumentChange.fromJSON(e))
        : [],
    };
  },

  toJSON(message: UpdateDraftRequestV2): unknown {
    const obj: any = {};
    message.documentId !== undefined && (obj.documentId = message.documentId);
    if (message.changes) {
      obj.changes = message.changes.map((e) =>
        e ? DocumentChange.toJSON(e) : undefined
      );
    } else {
      obj.changes = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<UpdateDraftRequestV2>, I>>(
    object: I
  ): UpdateDraftRequestV2 {
    const message = createBaseUpdateDraftRequestV2();
    message.documentId = object.documentId ?? "";
    message.changes =
      object.changes?.map((e) => DocumentChange.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDocumentChange(): DocumentChange {
  return { op: undefined };
}

export const DocumentChange = {
  encode(
    message: DocumentChange,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.op?.$case === "setTitle") {
      writer.uint32(10).string(message.op.setTitle);
    }
    if (message.op?.$case === "setSubtitle") {
      writer.uint32(18).string(message.op.setSubtitle);
    }
    if (message.op?.$case === "moveBlock") {
      DocumentChange_MoveBlock.encode(
        message.op.moveBlock,
        writer.uint32(26).fork()
      ).ldelim();
    }
    if (message.op?.$case === "replaceBlock") {
      Block.encode(message.op.replaceBlock, writer.uint32(34).fork()).ldelim();
    }
    if (message.op?.$case === "deleteBlock") {
      writer.uint32(42).string(message.op.deleteBlock);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DocumentChange {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocumentChange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.op = { $case: "setTitle", setTitle: reader.string() };
          break;
        case 2:
          message.op = { $case: "setSubtitle", setSubtitle: reader.string() };
          break;
        case 3:
          message.op = {
            $case: "moveBlock",
            moveBlock: DocumentChange_MoveBlock.decode(reader, reader.uint32()),
          };
          break;
        case 4:
          message.op = {
            $case: "replaceBlock",
            replaceBlock: Block.decode(reader, reader.uint32()),
          };
          break;
        case 5:
          message.op = { $case: "deleteBlock", deleteBlock: reader.string() };
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DocumentChange {
    return {
      op: isSet(object.setTitle)
        ? { $case: "setTitle", setTitle: String(object.setTitle) }
        : isSet(object.setSubtitle)
        ? { $case: "setSubtitle", setSubtitle: String(object.setSubtitle) }
        : isSet(object.moveBlock)
        ? {
            $case: "moveBlock",
            moveBlock: DocumentChange_MoveBlock.fromJSON(object.moveBlock),
          }
        : isSet(object.replaceBlock)
        ? {
            $case: "replaceBlock",
            replaceBlock: Block.fromJSON(object.replaceBlock),
          }
        : isSet(object.deleteBlock)
        ? { $case: "deleteBlock", deleteBlock: String(object.deleteBlock) }
        : undefined,
    };
  },

  toJSON(message: DocumentChange): unknown {
    const obj: any = {};
    message.op?.$case === "setTitle" && (obj.setTitle = message.op?.setTitle);
    message.op?.$case === "setSubtitle" &&
      (obj.setSubtitle = message.op?.setSubtitle);
    message.op?.$case === "moveBlock" &&
      (obj.moveBlock = message.op?.moveBlock
        ? DocumentChange_MoveBlock.toJSON(message.op?.moveBlock)
        : undefined);
    message.op?.$case === "replaceBlock" &&
      (obj.replaceBlock = message.op?.replaceBlock
        ? Block.toJSON(message.op?.replaceBlock)
        : undefined);
    message.op?.$case === "deleteBlock" &&
      (obj.deleteBlock = message.op?.deleteBlock);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<DocumentChange>, I>>(
    object: I
  ): DocumentChange {
    const message = createBaseDocumentChange();
    if (
      object.op?.$case === "setTitle" &&
      object.op?.setTitle !== undefined &&
      object.op?.setTitle !== null
    ) {
      message.op = { $case: "setTitle", setTitle: object.op.setTitle };
    }
    if (
      object.op?.$case === "setSubtitle" &&
      object.op?.setSubtitle !== undefined &&
      object.op?.setSubtitle !== null
    ) {
      message.op = { $case: "setSubtitle", setSubtitle: object.op.setSubtitle };
    }
    if (
      object.op?.$case === "moveBlock" &&
      object.op?.moveBlock !== undefined &&
      object.op?.moveBlock !== null
    ) {
      message.op = {
        $case: "moveBlock",
        moveBlock: DocumentChange_MoveBlock.fromPartial(object.op.moveBlock),
      };
    }
    if (
      object.op?.$case === "replaceBlock" &&
      object.op?.replaceBlock !== undefined &&
      object.op?.replaceBlock !== null
    ) {
      message.op = {
        $case: "replaceBlock",
        replaceBlock: Block.fromPartial(object.op.replaceBlock),
      };
    }
    if (
      object.op?.$case === "deleteBlock" &&
      object.op?.deleteBlock !== undefined &&
      object.op?.deleteBlock !== null
    ) {
      message.op = { $case: "deleteBlock", deleteBlock: object.op.deleteBlock };
    }
    return message;
  },
};

function createBaseDocumentChange_MoveBlock(): DocumentChange_MoveBlock {
  return { blockId: "", parent: "", leftSibling: "" };
}

export const DocumentChange_MoveBlock = {
  encode(
    message: DocumentChange_MoveBlock,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.blockId !== "") {
      writer.uint32(10).string(message.blockId);
    }
    if (message.parent !== "") {
      writer.uint32(18).string(message.parent);
    }
    if (message.leftSibling !== "") {
      writer.uint32(26).string(message.leftSibling);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): DocumentChange_MoveBlock {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocumentChange_MoveBlock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.blockId = reader.string();
          break;
        case 2:
          message.parent = reader.string();
          break;
        case 3:
          message.leftSibling = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DocumentChange_MoveBlock {
    return {
      blockId: isSet(object.blockId) ? String(object.blockId) : "",
      parent: isSet(object.parent) ? String(object.parent) : "",
      leftSibling: isSet(object.leftSibling) ? String(object.leftSibling) : "",
    };
  },

  toJSON(message: DocumentChange_MoveBlock): unknown {
    const obj: any = {};
    message.blockId !== undefined && (obj.blockId = message.blockId);
    message.parent !== undefined && (obj.parent = message.parent);
    message.leftSibling !== undefined &&
      (obj.leftSibling = message.leftSibling);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<DocumentChange_MoveBlock>, I>>(
    object: I
  ): DocumentChange_MoveBlock {
    const message = createBaseDocumentChange_MoveBlock();
    message.blockId = object.blockId ?? "";
    message.parent = object.parent ?? "";
    message.leftSibling = object.leftSibling ?? "";
    return message;
  },
};

function createBaseListDraftsRequest(): ListDraftsRequest {
  return { pageSize: 0, pageToken: "" };
}

export const ListDraftsRequest = {
  encode(
    message: ListDraftsRequest,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.pageSize !== 0) {
      writer.uint32(8).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(18).string(message.pageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListDraftsRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDraftsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.pageSize = reader.int32();
          break;
        case 2:
          message.pageToken = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ListDraftsRequest {
    return {
      pageSize: isSet(object.pageSize) ? Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? String(object.pageToken) : "",
    };
  },

  toJSON(message: ListDraftsRequest): unknown {
    const obj: any = {};
    message.pageSize !== undefined &&
      (obj.pageSize = Math.round(message.pageSize));
    message.pageToken !== undefined && (obj.pageToken = message.pageToken);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ListDraftsRequest>, I>>(
    object: I
  ): ListDraftsRequest {
    const message = createBaseListDraftsRequest();
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListDraftsResponse(): ListDraftsResponse {
  return { documents: [], nextPageToken: "" };
}

export const ListDraftsResponse = {
  encode(
    message: ListDraftsResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    for (const v of message.documents) {
      Document.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListDraftsResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDraftsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.documents.push(Document.decode(reader, reader.uint32()));
          break;
        case 2:
          message.nextPageToken = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ListDraftsResponse {
    return {
      documents: Array.isArray(object?.documents)
        ? object.documents.map((e: any) => Document.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken)
        ? String(object.nextPageToken)
        : "",
    };
  },

  toJSON(message: ListDraftsResponse): unknown {
    const obj: any = {};
    if (message.documents) {
      obj.documents = message.documents.map((e) =>
        e ? Document.toJSON(e) : undefined
      );
    } else {
      obj.documents = [];
    }
    message.nextPageToken !== undefined &&
      (obj.nextPageToken = message.nextPageToken);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ListDraftsResponse>, I>>(
    object: I
  ): ListDraftsResponse {
    const message = createBaseListDraftsResponse();
    message.documents =
      object.documents?.map((e) => Document.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBasePublishDraftRequest(): PublishDraftRequest {
  return { documentId: "" };
}

export const PublishDraftRequest = {
  encode(
    message: PublishDraftRequest,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.documentId !== "") {
      writer.uint32(10).string(message.documentId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PublishDraftRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublishDraftRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.documentId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PublishDraftRequest {
    return {
      documentId: isSet(object.documentId) ? String(object.documentId) : "",
    };
  },

  toJSON(message: PublishDraftRequest): unknown {
    const obj: any = {};
    message.documentId !== undefined && (obj.documentId = message.documentId);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<PublishDraftRequest>, I>>(
    object: I
  ): PublishDraftRequest {
    const message = createBasePublishDraftRequest();
    message.documentId = object.documentId ?? "";
    return message;
  },
};

function createBaseGetPublicationRequest(): GetPublicationRequest {
  return { documentId: "", version: "" };
}

export const GetPublicationRequest = {
  encode(
    message: GetPublicationRequest,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.documentId !== "") {
      writer.uint32(10).string(message.documentId);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetPublicationRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPublicationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.documentId = reader.string();
          break;
        case 2:
          message.version = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetPublicationRequest {
    return {
      documentId: isSet(object.documentId) ? String(object.documentId) : "",
      version: isSet(object.version) ? String(object.version) : "",
    };
  },

  toJSON(message: GetPublicationRequest): unknown {
    const obj: any = {};
    message.documentId !== undefined && (obj.documentId = message.documentId);
    message.version !== undefined && (obj.version = message.version);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetPublicationRequest>, I>>(
    object: I
  ): GetPublicationRequest {
    const message = createBaseGetPublicationRequest();
    message.documentId = object.documentId ?? "";
    message.version = object.version ?? "";
    return message;
  },
};

function createBaseDeletePublicationRequest(): DeletePublicationRequest {
  return { documentId: "" };
}

export const DeletePublicationRequest = {
  encode(
    message: DeletePublicationRequest,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.documentId !== "") {
      writer.uint32(10).string(message.documentId);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): DeletePublicationRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeletePublicationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.documentId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DeletePublicationRequest {
    return {
      documentId: isSet(object.documentId) ? String(object.documentId) : "",
    };
  },

  toJSON(message: DeletePublicationRequest): unknown {
    const obj: any = {};
    message.documentId !== undefined && (obj.documentId = message.documentId);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<DeletePublicationRequest>, I>>(
    object: I
  ): DeletePublicationRequest {
    const message = createBaseDeletePublicationRequest();
    message.documentId = object.documentId ?? "";
    return message;
  },
};

function createBaseListPublicationsRequest(): ListPublicationsRequest {
  return { pageSize: 0, pageToken: "" };
}

export const ListPublicationsRequest = {
  encode(
    message: ListPublicationsRequest,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.pageSize !== 0) {
      writer.uint32(8).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(18).string(message.pageToken);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): ListPublicationsRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPublicationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.pageSize = reader.int32();
          break;
        case 2:
          message.pageToken = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ListPublicationsRequest {
    return {
      pageSize: isSet(object.pageSize) ? Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? String(object.pageToken) : "",
    };
  },

  toJSON(message: ListPublicationsRequest): unknown {
    const obj: any = {};
    message.pageSize !== undefined &&
      (obj.pageSize = Math.round(message.pageSize));
    message.pageToken !== undefined && (obj.pageToken = message.pageToken);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ListPublicationsRequest>, I>>(
    object: I
  ): ListPublicationsRequest {
    const message = createBaseListPublicationsRequest();
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListPublicationsResponse(): ListPublicationsResponse {
  return { publications: [], nextPageToken: "" };
}

export const ListPublicationsResponse = {
  encode(
    message: ListPublicationsResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    for (const v of message.publications) {
      Publication.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): ListPublicationsResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPublicationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.publications.push(
            Publication.decode(reader, reader.uint32())
          );
          break;
        case 2:
          message.nextPageToken = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ListPublicationsResponse {
    return {
      publications: Array.isArray(object?.publications)
        ? object.publications.map((e: any) => Publication.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken)
        ? String(object.nextPageToken)
        : "",
    };
  },

  toJSON(message: ListPublicationsResponse): unknown {
    const obj: any = {};
    if (message.publications) {
      obj.publications = message.publications.map((e) =>
        e ? Publication.toJSON(e) : undefined
      );
    } else {
      obj.publications = [];
    }
    message.nextPageToken !== undefined &&
      (obj.nextPageToken = message.nextPageToken);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ListPublicationsResponse>, I>>(
    object: I
  ): ListPublicationsResponse {
    const message = createBaseListPublicationsResponse();
    message.publications =
      object.publications?.map((e) => Publication.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseListCitationsRequest(): ListCitationsRequest {
  return { documentId: "", depth: 0 };
}

export const ListCitationsRequest = {
  encode(
    message: ListCitationsRequest,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.documentId !== "") {
      writer.uint32(10).string(message.documentId);
    }
    if (message.depth !== 0) {
      writer.uint32(16).int32(message.depth);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): ListCitationsRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCitationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.documentId = reader.string();
          break;
        case 2:
          message.depth = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ListCitationsRequest {
    return {
      documentId: isSet(object.documentId) ? String(object.documentId) : "",
      depth: isSet(object.depth) ? Number(object.depth) : 0,
    };
  },

  toJSON(message: ListCitationsRequest): unknown {
    const obj: any = {};
    message.documentId !== undefined && (obj.documentId = message.documentId);
    message.depth !== undefined && (obj.depth = Math.round(message.depth));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ListCitationsRequest>, I>>(
    object: I
  ): ListCitationsRequest {
    const message = createBaseListCitationsRequest();
    message.documentId = object.documentId ?? "";
    message.depth = object.depth ?? 0;
    return message;
  },
};

function createBaseListCitationsResponse(): ListCitationsResponse {
  return { links: [] };
}

export const ListCitationsResponse = {
  encode(
    message: ListCitationsResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    for (const v of message.links) {
      Link.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): ListCitationsResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCitationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.links.push(Link.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ListCitationsResponse {
    return {
      links: Array.isArray(object?.links)
        ? object.links.map((e: any) => Link.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListCitationsResponse): unknown {
    const obj: any = {};
    if (message.links) {
      obj.links = message.links.map((e) => (e ? Link.toJSON(e) : undefined));
    } else {
      obj.links = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ListCitationsResponse>, I>>(
    object: I
  ): ListCitationsResponse {
    const message = createBaseListCitationsResponse();
    message.links = object.links?.map((e) => Link.fromPartial(e)) || [];
    return message;
  },
};

function createBasePublication(): Publication {
  return { version: "", document: undefined };
}

export const Publication = {
  encode(
    message: Publication,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    if (message.document !== undefined) {
      Document.encode(message.document, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Publication {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublication();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.version = reader.string();
          break;
        case 2:
          message.document = Document.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Publication {
    return {
      version: isSet(object.version) ? String(object.version) : "",
      document: isSet(object.document)
        ? Document.fromJSON(object.document)
        : undefined,
    };
  },

  toJSON(message: Publication): unknown {
    const obj: any = {};
    message.version !== undefined && (obj.version = message.version);
    message.document !== undefined &&
      (obj.document = message.document
        ? Document.toJSON(message.document)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<Publication>, I>>(
    object: I
  ): Publication {
    const message = createBasePublication();
    message.version = object.version ?? "";
    message.document =
      object.document !== undefined && object.document !== null
        ? Document.fromPartial(object.document)
        : undefined;
    return message;
  },
};

function createBaseDocument(): Document {
  return {
    id: "",
    title: "",
    subtitle: "",
    author: "",
    children: [],
    createTime: undefined,
    updateTime: undefined,
    publishTime: undefined,
  };
}

export const Document = {
  encode(
    message: Document,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.subtitle !== "") {
      writer.uint32(26).string(message.subtitle);
    }
    if (message.author !== "") {
      writer.uint32(34).string(message.author);
    }
    for (const v of message.children) {
      BlockNode.encode(v!, writer.uint32(74).fork()).ldelim();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(
        toTimestamp(message.createTime),
        writer.uint32(50).fork()
      ).ldelim();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(
        toTimestamp(message.updateTime),
        writer.uint32(58).fork()
      ).ldelim();
    }
    if (message.publishTime !== undefined) {
      Timestamp.encode(
        toTimestamp(message.publishTime),
        writer.uint32(66).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Document {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.title = reader.string();
          break;
        case 3:
          message.subtitle = reader.string();
          break;
        case 4:
          message.author = reader.string();
          break;
        case 9:
          message.children.push(BlockNode.decode(reader, reader.uint32()));
          break;
        case 6:
          message.createTime = fromTimestamp(
            Timestamp.decode(reader, reader.uint32())
          );
          break;
        case 7:
          message.updateTime = fromTimestamp(
            Timestamp.decode(reader, reader.uint32())
          );
          break;
        case 8:
          message.publishTime = fromTimestamp(
            Timestamp.decode(reader, reader.uint32())
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Document {
    return {
      id: isSet(object.id) ? String(object.id) : "",
      title: isSet(object.title) ? String(object.title) : "",
      subtitle: isSet(object.subtitle) ? String(object.subtitle) : "",
      author: isSet(object.author) ? String(object.author) : "",
      children: Array.isArray(object?.children)
        ? object.children.map((e: any) => BlockNode.fromJSON(e))
        : [],
      createTime: isSet(object.createTime)
        ? fromJsonTimestamp(object.createTime)
        : undefined,
      updateTime: isSet(object.updateTime)
        ? fromJsonTimestamp(object.updateTime)
        : undefined,
      publishTime: isSet(object.publishTime)
        ? fromJsonTimestamp(object.publishTime)
        : undefined,
    };
  },

  toJSON(message: Document): unknown {
    const obj: any = {};
    message.id !== undefined && (obj.id = message.id);
    message.title !== undefined && (obj.title = message.title);
    message.subtitle !== undefined && (obj.subtitle = message.subtitle);
    message.author !== undefined && (obj.author = message.author);
    if (message.children) {
      obj.children = message.children.map((e) =>
        e ? BlockNode.toJSON(e) : undefined
      );
    } else {
      obj.children = [];
    }
    message.createTime !== undefined &&
      (obj.createTime = message.createTime.toISOString());
    message.updateTime !== undefined &&
      (obj.updateTime = message.updateTime.toISOString());
    message.publishTime !== undefined &&
      (obj.publishTime = message.publishTime.toISOString());
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<Document>, I>>(object: I): Document {
    const message = createBaseDocument();
    message.id = object.id ?? "";
    message.title = object.title ?? "";
    message.subtitle = object.subtitle ?? "";
    message.author = object.author ?? "";
    message.children =
      object.children?.map((e) => BlockNode.fromPartial(e)) || [];
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.publishTime = object.publishTime ?? undefined;
    return message;
  },
};

function createBaseBlockNode(): BlockNode {
  return { block: undefined, children: [] };
}

export const BlockNode = {
  encode(
    message: BlockNode,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.block !== undefined) {
      Block.encode(message.block, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.children) {
      BlockNode.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BlockNode {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.block = Block.decode(reader, reader.uint32());
          break;
        case 2:
          message.children.push(BlockNode.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BlockNode {
    return {
      block: isSet(object.block) ? Block.fromJSON(object.block) : undefined,
      children: Array.isArray(object?.children)
        ? object.children.map((e: any) => BlockNode.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BlockNode): unknown {
    const obj: any = {};
    message.block !== undefined &&
      (obj.block = message.block ? Block.toJSON(message.block) : undefined);
    if (message.children) {
      obj.children = message.children.map((e) =>
        e ? BlockNode.toJSON(e) : undefined
      );
    } else {
      obj.children = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<BlockNode>, I>>(
    object: I
  ): BlockNode {
    const message = createBaseBlockNode();
    message.block =
      object.block !== undefined && object.block !== null
        ? Block.fromPartial(object.block)
        : undefined;
    message.children =
      object.children?.map((e) => BlockNode.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBlock(): Block {
  return { id: "", type: "", text: "", attributes: {}, annotations: [] };
}

export const Block = {
  encode(message: Block, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    if (message.text !== "") {
      writer.uint32(26).string(message.text);
    }
    Object.entries(message.attributes).forEach(([key, value]) => {
      Block_AttributesEntry.encode(
        { key: key as any, value },
        writer.uint32(34).fork()
      ).ldelim();
    });
    for (const v of message.annotations) {
      Annotation.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Block {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.type = reader.string();
          break;
        case 3:
          message.text = reader.string();
          break;
        case 4:
          const entry4 = Block_AttributesEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.attributes[entry4.key] = entry4.value;
          }
          break;
        case 5:
          message.annotations.push(Annotation.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Block {
    return {
      id: isSet(object.id) ? String(object.id) : "",
      type: isSet(object.type) ? String(object.type) : "",
      text: isSet(object.text) ? String(object.text) : "",
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<{ [key: string]: string }>(
            (acc, [key, value]) => {
              acc[key] = String(value);
              return acc;
            },
            {}
          )
        : {},
      annotations: Array.isArray(object?.annotations)
        ? object.annotations.map((e: any) => Annotation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Block): unknown {
    const obj: any = {};
    message.id !== undefined && (obj.id = message.id);
    message.type !== undefined && (obj.type = message.type);
    message.text !== undefined && (obj.text = message.text);
    obj.attributes = {};
    if (message.attributes) {
      Object.entries(message.attributes).forEach(([k, v]) => {
        obj.attributes[k] = v;
      });
    }
    if (message.annotations) {
      obj.annotations = message.annotations.map((e) =>
        e ? Annotation.toJSON(e) : undefined
      );
    } else {
      obj.annotations = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<Block>, I>>(object: I): Block {
    const message = createBaseBlock();
    message.id = object.id ?? "";
    message.type = object.type ?? "";
    message.text = object.text ?? "";
    message.attributes = Object.entries(object.attributes ?? {}).reduce<{
      [key: string]: string;
    }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = String(value);
      }
      return acc;
    }, {});
    message.annotations =
      object.annotations?.map((e) => Annotation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBlock_AttributesEntry(): Block_AttributesEntry {
  return { key: "", value: "" };
}

export const Block_AttributesEntry = {
  encode(
    message: Block_AttributesEntry,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): Block_AttributesEntry {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlock_AttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Block_AttributesEntry {
    return {
      key: isSet(object.key) ? String(object.key) : "",
      value: isSet(object.value) ? String(object.value) : "",
    };
  },

  toJSON(message: Block_AttributesEntry): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = message.key);
    message.value !== undefined && (obj.value = message.value);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<Block_AttributesEntry>, I>>(
    object: I
  ): Block_AttributesEntry {
    const message = createBaseBlock_AttributesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAnnotation(): Annotation {
  return { type: "", attributes: {}, starts: [], ends: [] };
}

export const Annotation = {
  encode(
    message: Annotation,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    Object.entries(message.attributes).forEach(([key, value]) => {
      Annotation_AttributesEntry.encode(
        { key: key as any, value },
        writer.uint32(18).fork()
      ).ldelim();
    });
    writer.uint32(26).fork();
    for (const v of message.starts) {
      writer.int32(v);
    }
    writer.ldelim();
    writer.uint32(34).fork();
    for (const v of message.ends) {
      writer.int32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Annotation {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnnotation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.type = reader.string();
          break;
        case 2:
          const entry2 = Annotation_AttributesEntry.decode(
            reader,
            reader.uint32()
          );
          if (entry2.value !== undefined) {
            message.attributes[entry2.key] = entry2.value;
          }
          break;
        case 3:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.starts.push(reader.int32());
            }
          } else {
            message.starts.push(reader.int32());
          }
          break;
        case 4:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.ends.push(reader.int32());
            }
          } else {
            message.ends.push(reader.int32());
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Annotation {
    return {
      type: isSet(object.type) ? String(object.type) : "",
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<{ [key: string]: string }>(
            (acc, [key, value]) => {
              acc[key] = String(value);
              return acc;
            },
            {}
          )
        : {},
      starts: Array.isArray(object?.starts)
        ? object.starts.map((e: any) => Number(e))
        : [],
      ends: Array.isArray(object?.ends)
        ? object.ends.map((e: any) => Number(e))
        : [],
    };
  },

  toJSON(message: Annotation): unknown {
    const obj: any = {};
    message.type !== undefined && (obj.type = message.type);
    obj.attributes = {};
    if (message.attributes) {
      Object.entries(message.attributes).forEach(([k, v]) => {
        obj.attributes[k] = v;
      });
    }
    if (message.starts) {
      obj.starts = message.starts.map((e) => Math.round(e));
    } else {
      obj.starts = [];
    }
    if (message.ends) {
      obj.ends = message.ends.map((e) => Math.round(e));
    } else {
      obj.ends = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<Annotation>, I>>(
    object: I
  ): Annotation {
    const message = createBaseAnnotation();
    message.type = object.type ?? "";
    message.attributes = Object.entries(object.attributes ?? {}).reduce<{
      [key: string]: string;
    }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = String(value);
      }
      return acc;
    }, {});
    message.starts = object.starts?.map((e) => e) || [];
    message.ends = object.ends?.map((e) => e) || [];
    return message;
  },
};

function createBaseAnnotation_AttributesEntry(): Annotation_AttributesEntry {
  return { key: "", value: "" };
}

export const Annotation_AttributesEntry = {
  encode(
    message: Annotation_AttributesEntry,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): Annotation_AttributesEntry {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnnotation_AttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Annotation_AttributesEntry {
    return {
      key: isSet(object.key) ? String(object.key) : "",
      value: isSet(object.value) ? String(object.value) : "",
    };
  },

  toJSON(message: Annotation_AttributesEntry): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = message.key);
    message.value !== undefined && (obj.value = message.value);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<Annotation_AttributesEntry>, I>>(
    object: I
  ): Annotation_AttributesEntry {
    const message = createBaseAnnotation_AttributesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseLink(): Link {
  return { source: undefined, target: undefined };
}

export const Link = {
  encode(message: Link, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.source !== undefined) {
      LinkNode.encode(message.source, writer.uint32(10).fork()).ldelim();
    }
    if (message.target !== undefined) {
      LinkNode.encode(message.target, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Link {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLink();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.source = LinkNode.decode(reader, reader.uint32());
          break;
        case 2:
          message.target = LinkNode.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Link {
    return {
      source: isSet(object.source)
        ? LinkNode.fromJSON(object.source)
        : undefined,
      target: isSet(object.target)
        ? LinkNode.fromJSON(object.target)
        : undefined,
    };
  },

  toJSON(message: Link): unknown {
    const obj: any = {};
    message.source !== undefined &&
      (obj.source = message.source
        ? LinkNode.toJSON(message.source)
        : undefined);
    message.target !== undefined &&
      (obj.target = message.target
        ? LinkNode.toJSON(message.target)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<Link>, I>>(object: I): Link {
    const message = createBaseLink();
    message.source =
      object.source !== undefined && object.source !== null
        ? LinkNode.fromPartial(object.source)
        : undefined;
    message.target =
      object.target !== undefined && object.target !== null
        ? LinkNode.fromPartial(object.target)
        : undefined;
    return message;
  },
};

function createBaseLinkNode(): LinkNode {
  return { documentId: "", version: "", blockId: "" };
}

export const LinkNode = {
  encode(
    message: LinkNode,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.documentId !== "") {
      writer.uint32(10).string(message.documentId);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    if (message.blockId !== "") {
      writer.uint32(26).string(message.blockId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LinkNode {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.documentId = reader.string();
          break;
        case 2:
          message.version = reader.string();
          break;
        case 3:
          message.blockId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): LinkNode {
    return {
      documentId: isSet(object.documentId) ? String(object.documentId) : "",
      version: isSet(object.version) ? String(object.version) : "",
      blockId: isSet(object.blockId) ? String(object.blockId) : "",
    };
  },

  toJSON(message: LinkNode): unknown {
    const obj: any = {};
    message.documentId !== undefined && (obj.documentId = message.documentId);
    message.version !== undefined && (obj.version = message.version);
    message.blockId !== undefined && (obj.blockId = message.blockId);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<LinkNode>, I>>(object: I): LinkNode {
    const message = createBaseLinkNode();
    message.documentId = object.documentId ?? "";
    message.version = object.version ?? "";
    message.blockId = object.blockId ?? "";
    return message;
  },
};

/** Drafts service exposes the functionality */
export interface Drafts {
  /** Creates a new draft with a new permanent document ID. */
  createDraft(
    request: DeepPartial<CreateDraftRequest>,
    metadata?: grpc.Metadata
  ): Promise<Document>;
  /** Deletes a draft by its document ID. */
  deleteDraft(
    request: DeepPartial<DeleteDraftRequest>,
    metadata?: grpc.Metadata
  ): Promise<Empty>;
  /** Gets a single draft if exists. */
  getDraft(
    request: DeepPartial<GetDraftRequest>,
    metadata?: grpc.Metadata
  ): Promise<Document>;
  /** Updates a draft using granular update operations. */
  updateDraftV2(
    request: DeepPartial<UpdateDraftRequestV2>,
    metadata?: grpc.Metadata
  ): Promise<Empty>;
  /** List currently stored drafts. */
  listDrafts(
    request: DeepPartial<ListDraftsRequest>,
    metadata?: grpc.Metadata
  ): Promise<ListDraftsResponse>;
  /** Publishes a draft. I.e. draft will become a publication, and will no longer appear in drafts section. */
  publishDraft(
    request: DeepPartial<PublishDraftRequest>,
    metadata?: grpc.Metadata
  ): Promise<Publication>;
}

export class DraftsClientImpl implements Drafts {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.createDraft = this.createDraft.bind(this);
    this.deleteDraft = this.deleteDraft.bind(this);
    this.getDraft = this.getDraft.bind(this);
    this.updateDraftV2 = this.updateDraftV2.bind(this);
    this.listDrafts = this.listDrafts.bind(this);
    this.publishDraft = this.publishDraft.bind(this);
  }

  createDraft(
    request: DeepPartial<CreateDraftRequest>,
    metadata?: grpc.Metadata
  ): Promise<Document> {
    return this.rpc.unary(
      DraftsCreateDraftDesc,
      CreateDraftRequest.fromPartial(request),
      metadata
    );
  }

  deleteDraft(
    request: DeepPartial<DeleteDraftRequest>,
    metadata?: grpc.Metadata
  ): Promise<Empty> {
    return this.rpc.unary(
      DraftsDeleteDraftDesc,
      DeleteDraftRequest.fromPartial(request),
      metadata
    );
  }

  getDraft(
    request: DeepPartial<GetDraftRequest>,
    metadata?: grpc.Metadata
  ): Promise<Document> {
    return this.rpc.unary(
      DraftsGetDraftDesc,
      GetDraftRequest.fromPartial(request),
      metadata
    );
  }

  updateDraftV2(
    request: DeepPartial<UpdateDraftRequestV2>,
    metadata?: grpc.Metadata
  ): Promise<Empty> {
    return this.rpc.unary(
      DraftsUpdateDraftV2Desc,
      UpdateDraftRequestV2.fromPartial(request),
      metadata
    );
  }

  listDrafts(
    request: DeepPartial<ListDraftsRequest>,
    metadata?: grpc.Metadata
  ): Promise<ListDraftsResponse> {
    return this.rpc.unary(
      DraftsListDraftsDesc,
      ListDraftsRequest.fromPartial(request),
      metadata
    );
  }

  publishDraft(
    request: DeepPartial<PublishDraftRequest>,
    metadata?: grpc.Metadata
  ): Promise<Publication> {
    return this.rpc.unary(
      DraftsPublishDraftDesc,
      PublishDraftRequest.fromPartial(request),
      metadata
    );
  }
}

export const DraftsDesc = {
  serviceName: "com.mintter.documents.v1alpha.Drafts",
};

export const DraftsCreateDraftDesc: UnaryMethodDefinitionish = {
  methodName: "CreateDraft",
  service: DraftsDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return CreateDraftRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      return {
        ...Document.decode(data),
        toObject() {
          return this;
        },
      };
    },
  } as any,
};

export const DraftsDeleteDraftDesc: UnaryMethodDefinitionish = {
  methodName: "DeleteDraft",
  service: DraftsDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return DeleteDraftRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      return {
        ...Empty.decode(data),
        toObject() {
          return this;
        },
      };
    },
  } as any,
};

export const DraftsGetDraftDesc: UnaryMethodDefinitionish = {
  methodName: "GetDraft",
  service: DraftsDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetDraftRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      return {
        ...Document.decode(data),
        toObject() {
          return this;
        },
      };
    },
  } as any,
};

export const DraftsUpdateDraftV2Desc: UnaryMethodDefinitionish = {
  methodName: "UpdateDraftV2",
  service: DraftsDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return UpdateDraftRequestV2.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      return {
        ...Empty.decode(data),
        toObject() {
          return this;
        },
      };
    },
  } as any,
};

export const DraftsListDraftsDesc: UnaryMethodDefinitionish = {
  methodName: "ListDrafts",
  service: DraftsDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ListDraftsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      return {
        ...ListDraftsResponse.decode(data),
        toObject() {
          return this;
        },
      };
    },
  } as any,
};

export const DraftsPublishDraftDesc: UnaryMethodDefinitionish = {
  methodName: "PublishDraft",
  service: DraftsDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return PublishDraftRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      return {
        ...Publication.decode(data),
        toObject() {
          return this;
        },
      };
    },
  } as any,
};

/** Publications service provides access to published documents. */
export interface Publications {
  /** Gets a single publication. */
  getPublication(
    request: DeepPartial<GetPublicationRequest>,
    metadata?: grpc.Metadata
  ): Promise<Publication>;
  /** Deletes a publication from the local node. It removes all the patches corresponding to a document. */
  deletePublication(
    request: DeepPartial<DeletePublicationRequest>,
    metadata?: grpc.Metadata
  ): Promise<Empty>;
  /** Lists stored publications. Only the most recent versions show up. */
  listPublications(
    request: DeepPartial<ListPublicationsRequest>,
    metadata?: grpc.Metadata
  ): Promise<ListPublicationsResponse>;
}

export class PublicationsClientImpl implements Publications {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.getPublication = this.getPublication.bind(this);
    this.deletePublication = this.deletePublication.bind(this);
    this.listPublications = this.listPublications.bind(this);
  }

  getPublication(
    request: DeepPartial<GetPublicationRequest>,
    metadata?: grpc.Metadata
  ): Promise<Publication> {
    return this.rpc.unary(
      PublicationsGetPublicationDesc,
      GetPublicationRequest.fromPartial(request),
      metadata
    );
  }

  deletePublication(
    request: DeepPartial<DeletePublicationRequest>,
    metadata?: grpc.Metadata
  ): Promise<Empty> {
    return this.rpc.unary(
      PublicationsDeletePublicationDesc,
      DeletePublicationRequest.fromPartial(request),
      metadata
    );
  }

  listPublications(
    request: DeepPartial<ListPublicationsRequest>,
    metadata?: grpc.Metadata
  ): Promise<ListPublicationsResponse> {
    return this.rpc.unary(
      PublicationsListPublicationsDesc,
      ListPublicationsRequest.fromPartial(request),
      metadata
    );
  }
}

export const PublicationsDesc = {
  serviceName: "com.mintter.documents.v1alpha.Publications",
};

export const PublicationsGetPublicationDesc: UnaryMethodDefinitionish = {
  methodName: "GetPublication",
  service: PublicationsDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetPublicationRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      return {
        ...Publication.decode(data),
        toObject() {
          return this;
        },
      };
    },
  } as any,
};

export const PublicationsDeletePublicationDesc: UnaryMethodDefinitionish = {
  methodName: "DeletePublication",
  service: PublicationsDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return DeletePublicationRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      return {
        ...Empty.decode(data),
        toObject() {
          return this;
        },
      };
    },
  } as any,
};

export const PublicationsListPublicationsDesc: UnaryMethodDefinitionish = {
  methodName: "ListPublications",
  service: PublicationsDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ListPublicationsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      return {
        ...ListPublicationsResponse.decode(data),
        toObject() {
          return this;
        },
      };
    },
  } as any,
};

/** Content graph service provides access to citations (backlinks). */
export interface ContentGraph {
  listCitations(
    request: DeepPartial<ListCitationsRequest>,
    metadata?: grpc.Metadata
  ): Promise<ListCitationsResponse>;
}

export class ContentGraphClientImpl implements ContentGraph {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.listCitations = this.listCitations.bind(this);
  }

  listCitations(
    request: DeepPartial<ListCitationsRequest>,
    metadata?: grpc.Metadata
  ): Promise<ListCitationsResponse> {
    return this.rpc.unary(
      ContentGraphListCitationsDesc,
      ListCitationsRequest.fromPartial(request),
      metadata
    );
  }
}

export const ContentGraphDesc = {
  serviceName: "com.mintter.documents.v1alpha.ContentGraph",
};

export const ContentGraphListCitationsDesc: UnaryMethodDefinitionish = {
  methodName: "ListCitations",
  service: ContentGraphDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ListCitationsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      return {
        ...ListCitationsResponse.decode(data),
        toObject() {
          return this;
        },
      };
    },
  } as any,
};

interface UnaryMethodDefinitionishR
  extends grpc.UnaryMethodDefinition<any, any> {
  requestStream: any;
  responseStream: any;
}

type UnaryMethodDefinitionish = UnaryMethodDefinitionishR;

interface Rpc {
  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    request: any,
    metadata: grpc.Metadata | undefined
  ): Promise<any>;
}

export class GrpcWebImpl {
  private host: string;
  private options: {
    transport?: grpc.TransportFactory;

    debug?: boolean;
    metadata?: grpc.Metadata;
    upStreamRetryCodes?: number[];
  };

  constructor(
    host: string,
    options: {
      transport?: grpc.TransportFactory;

      debug?: boolean;
      metadata?: grpc.Metadata;
      upStreamRetryCodes?: number[];
    }
  ) {
    this.host = host;
    this.options = options;
  }

  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    _request: any,
    metadata: grpc.Metadata | undefined
  ): Promise<any> {
    const request = { ..._request, ...methodDesc.requestType };
    const maybeCombinedMetadata =
      metadata && this.options.metadata
        ? new BrowserHeaders({
            ...this.options?.metadata.headersMap,
            ...metadata?.headersMap,
          })
        : metadata || this.options.metadata;
    return new Promise((resolve, reject) => {
      grpc.unary(methodDesc, {
        request,
        host: this.host,
        metadata: maybeCombinedMetadata,
        transport: this.options.transport,
        debug: this.options.debug,
        onEnd: function (response) {
          if (response.status === grpc.Code.OK) {
            resolve(response.message);
          } else {
            const err = new Error(response.statusMessage) as any;
            err.code = response.status;
            err.metadata = response.trailers;
            reject(err);
          }
        },
      });
    });
  }
}

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

type DeepPartial<T> = T extends Builtin
  ? T
  : T extends Array<infer U>
  ? Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U>
  ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string }
  ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & {
      $case: T["$case"];
    }
  : T extends {}
  ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<
        Exclude<keyof I, KeysOfUnion<P>>,
        never
      >;

function toTimestamp(date: Date): Timestamp {
  const seconds = date.getTime() / 1_000;
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = t.seconds * 1_000;
  millis += t.nanos / 1_000_000;
  return new Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof Date) {
    return o;
  } else if (typeof o === "string") {
    return new Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
